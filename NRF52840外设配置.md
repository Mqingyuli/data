# NRF52840外设配置

[toc]

## 1.SC7a20

### 1.1TWI初始化

```c
//TWI0初始化 
twi0_init ();
```

### 1.2SC7a20初始化

#### 1.2.1寄存器初始化

```c
static uint8_t SC7A20_REG[10] = {0x2F, 0xbc, 0x00, 0x88, 0x15, 0x06, 0x06, 0x02};
static uint8_t INIT1_REG[3] = {0xFF,0x42, 5};

static void init(const sc7a20_dev *dev);
static uint32_t sc7a20_get_regs(const sc7a20_dev *dev, uint8_t reg_addr, uint8_t *reg_data, uint8_t len);

static void init(const sc7a20_dev *dev)
{
    dev->write_buffer(dev->dev_addr, CTRL_REG1, &SC7A20_REG[0], 1); //ODR1 低功耗模式(10 Hz), 使能XYZ三轴, 正常模式
    dev->write_buffer(dev->dev_addr, CTRL_REG2, &SC7A20_REG[1], 1); // HPCLICK 开启高通滤波器(滤掉地球G)(一定要开启，否则阈值要超过1G，而且动作也要超过1G)
    dev->write_buffer(dev->dev_addr,CTRL_REG3, &SC7A20_REG[2],1); //BDU块更新模式使能，低字节数据在低地址,量程+/-2g，HR高精度模式
    dev->write_buffer(dev->dev_addr, CTRL_REG4, &SC7A20_REG[3], 1);    
    // dev->write_buffer(dev->dev_addr, CLICK_CFG, &SC7A20_REG[4], 1);    
    // dev->write_buffer(dev->dev_addr, CLICK_THS, &SC7A20_REG[5], 1);    
    // dev->write_buffer(dev->dev_addr, TIME_LIMIT, &SC7A20_REG[6], 1);   
    // dev->write_buffer(dev->dev_addr, TIME_LATENCY, &SC7A20_REG[7], 1); 
    
    dev->write_buffer(dev->dev_addr, INT1_CFG, &INIT1_REG[0], 1); //中断 1 配置
    dev->write_buffer(dev->dev_addr, INT1_THS, &INIT1_REG[1], 1); //中断 1 阈值寄存器
    dev->write_buffer(dev->dev_addr, INT1_DURATION, &INIT1_REG[2], 1);// 中断 1 持续时间
}
```

#### 1.2.2检查设备中的空指针  

```c
static int8_t null_ptr_check(const sc7a20_dev *dev)
{
    int8_t rslt;
    if (dev == NULL)
    {
        /* 发现空指针 */
        rslt = SC7A20_E_NULL_PTR;
    }
    else
    {
        rslt = SC7A20_OK;
    }
    return rslt;
}
```

#### 1.2.3给定寄存器地址读取数据  

```c
uint32_t sc7a20_get_regs(const sc7a20_dev *dev, uint8_t reg_addr, uint8_t *reg_data, uint8_t len)
{
    int8_t rslt;

    rslt = null_ptr_check(dev);
    if ((rslt == SC7A20_OK) && (reg_data != NULL))
    {
        rslt = dev->read_buffer(dev->dev_addr, reg_addr, reg_data, len);
        NRF_LOG_ERROR("sc7a20_get_regs  rslt:%d", rslt);
        /*检查通信错误并使用内部错误码屏蔽  */
        if (rslt != SC7A20_OK)
        {
            rslt = SC7A20_E_COMM_FAIL;
        }
    }
    else
    {
        rslt = SC7A20_E_NULL_PTR;
    }
    return rslt;
}
```

#### 1.2.4sc7a20初始化

```c
int8_t sc7a20_init(sc7a20_dev *dev)
{
    int8_t rslt;
    uint8_t try_count = 5;
    while (try_count)
    {
        rslt = sc7a20_get_regs(dev, SC7A20_WHOAMI_ADDR, &dev->chip_id, 1);
        if ((rslt == SC7A20_OK) &&
            (dev->chip_id == SC7A20_WHOAMI_VALUE))
        {
            init(dev);
            dev->init_flag = 1;
            break;
        }
        /* Wait for 10 ms */
        dev->delay_ms(10);
        --try_count;
    }
    return rslt;
}
```

### 1.3获取数据

```C

			acc_val_t acc_val_now = {0};
			uint8_t src_click = 0;
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x28, &acc_val_now.val[0], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x29, &acc_val_now.val[1], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2A, &acc_val_now.val[2], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2B, &acc_val_now.val[3], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2C, &acc_val_now.val[4], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2D, &acc_val_now.val[5], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x39, &src_click, 1);
			NRF_LOG_WARNING("SC7A20 CLICK_SRC:0x%02x, ACC VAL: %d %d %d", src_click,
							acc_val_now.val_xyz.x,
							acc_val_now.val_xyz.y,
							acc_val_now.val_xyz.z);
			switch (src_click)
			{
			case 0x5C:
				NRF_LOG_ERROR("Single click -> NZ");
				break;
			case 0x54:
				NRF_LOG_ERROR("Single click -> PZ");
				break;
			case 0x5A:
				NRF_LOG_ERROR("Single click -> NY");
				break;
			case 0x52:
				NRF_LOG_ERROR("Single click -> PY");
				break;
			case 0x59:
				NRF_LOG_ERROR("Single click -> NX");
				break;
			case 0x51:
				NRF_LOG_ERROR("Single click -> PX");
				break;
			}

			uint8_t int1_source = 0;
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, INT1_SOURCE, &int1_source, 1);
			NRF_LOG_DEBUG("INT1_SOURCE 0x%02x",int1_source);
			if(int1_source & 0x40)
			{
				NRF_LOG_ERROR("INT1_SOURCE IA");
			}
			if(int1_source & 0x20)
			{
				NRF_LOG_ERROR("INT1_SOURCE ZH");
			}
			if(int1_source & 0x10)
			{
				NRF_LOG_ERROR("INT1_SOURCE ZL");
			}
			if(int1_source & 0x08)
			{
				NRF_LOG_ERROR("INT1_SOURCE YH");
			}
			if(int1_source & 0x04)
			{
				NRF_LOG_ERROR("INT1_SOURCE YL");
			}
			if(int1_source & 0x02)
			{
				NRF_LOG_ERROR("INT1_SOURCE XH");
			}
			if(int1_source & 0x01)
			{
				NRF_LOG_ERROR("INT1_SOURCE XL");
			}
```

## 2.注意事项

```c
/*
1.配置了XYZ中断每次都会触发事件
2.AOI 位及 6D 位表示触发相应中断事件的规则为：若 AOI=0 为逻辑“或”，
    表示所配置好的所有中断事件只要有一个满足中断条件，就触发中断。若 AOI=1 为逻辑
    “与”，表示所配置好的所有中断事件必须所有都满足自身的中断条件，才能触发中断，相
    当于将所有中断进行了逻辑“与”操作。
3.可判断每次触发的事件是否有变化判断动静

*/
```

