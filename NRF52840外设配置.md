# NRF52840外设配置

[toc]

## 1.SC7a20

### 1.1TWI初始化

```c
//TWI0初始化 
twi0_init ();
```

### 1.2SC7a20初始化

#### 1.2.1寄存器初始化

```c
static uint8_t SC7A20_REG[10] = {0x2F, 0xbc, 0x00, 0x88, 0x15, 0x06, 0x06, 0x02};
static uint8_t INIT1_REG[3] = {0xFF,0x42, 5};

static void init(const sc7a20_dev *dev);
static uint32_t sc7a20_get_regs(const sc7a20_dev *dev, uint8_t reg_addr, uint8_t *reg_data, uint8_t len);

static void init(const sc7a20_dev *dev)
{
    dev->write_buffer(dev->dev_addr, CTRL_REG1, &SC7A20_REG[0], 1); //ODR1 低功耗模式(10 Hz), 使能XYZ三轴, 正常模式
    dev->write_buffer(dev->dev_addr, CTRL_REG2, &SC7A20_REG[1], 1); // HPCLICK 开启高通滤波器(滤掉地球G)(一定要开启，否则阈值要超过1G，而且动作也要超过1G)
    dev->write_buffer(dev->dev_addr,CTRL_REG3, &SC7A20_REG[2],1); //BDU块更新模式使能，低字节数据在低地址,量程+/-2g，HR高精度模式
    dev->write_buffer(dev->dev_addr, CTRL_REG4, &SC7A20_REG[3], 1);    
    // dev->write_buffer(dev->dev_addr, CLICK_CFG, &SC7A20_REG[4], 1);    
    // dev->write_buffer(dev->dev_addr, CLICK_THS, &SC7A20_REG[5], 1);    
    // dev->write_buffer(dev->dev_addr, TIME_LIMIT, &SC7A20_REG[6], 1);   
    // dev->write_buffer(dev->dev_addr, TIME_LATENCY, &SC7A20_REG[7], 1); 
    
    dev->write_buffer(dev->dev_addr, INT1_CFG, &INIT1_REG[0], 1); //中断 1 配置
    dev->write_buffer(dev->dev_addr, INT1_THS, &INIT1_REG[1], 1); //中断 1 阈值寄存器
    dev->write_buffer(dev->dev_addr, INT1_DURATION, &INIT1_REG[2], 1);// 中断 1 持续时间
}
```

#### 1.2.2检查设备中的空指针  

```c
static int8_t null_ptr_check(const sc7a20_dev *dev)
{
    int8_t rslt;
    if (dev == NULL)
    {
        /* 发现空指针 */
        rslt = SC7A20_E_NULL_PTR;
    }
    else
    {
        rslt = SC7A20_OK;
    }
    return rslt;
}
```

#### 1.2.3给定寄存器地址读取数据  

```c
uint32_t sc7a20_get_regs(const sc7a20_dev *dev, uint8_t reg_addr, uint8_t *reg_data, uint8_t len)
{
    int8_t rslt;

    rslt = null_ptr_check(dev);
    if ((rslt == SC7A20_OK) && (reg_data != NULL))
    {
        rslt = dev->read_buffer(dev->dev_addr, reg_addr, reg_data, len);
        NRF_LOG_ERROR("sc7a20_get_regs  rslt:%d", rslt);
        /*检查通信错误并使用内部错误码屏蔽  */
        if (rslt != SC7A20_OK)
        {
            rslt = SC7A20_E_COMM_FAIL;
        }
    }
    else
    {
        rslt = SC7A20_E_NULL_PTR;
    }
    return rslt;
}
```

#### 1.2.4sc7a20初始化

```c
int8_t sc7a20_init(sc7a20_dev *dev)
{
    int8_t rslt;
    uint8_t try_count = 5;
    //初始化判断五次初始化成功退出，以防没成功
    
    while (try_count)
    {
        rslt = sc7a20_get_regs(dev, SC7A20_WHOAMI_ADDR, &dev->chip_id, 1);
        if ((rslt == SC7A20_OK) &&
            (dev->chip_id == SC7A20_WHOAMI_VALUE))
        {
            init(dev);
            dev->init_flag = 1;
            break;
        }
        /* Wait for 10 ms */
        dev->delay_ms(10);
        --try_count;
    }
    return rslt;
}
```

### 1.3获取数据

```C
			/*存放数据的共用体*/
/*
         typedef union
            {
                struct
                {
                    int16_t x;
                    int16_t y;
                    int16_t z;
                } val_xyz;
                uint8_t val[6];
            } acc_val_t;
            XYZ每个等于两个val里面的元素 好处不要转换
*/
			acc_val_t acc_val_now = {0};
			uint8_t src_click = 0;
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x28, &acc_val_now.val[0], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x29, &acc_val_now.val[1], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2A, &acc_val_now.val[2], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2B, &acc_val_now.val[3], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2C, &acc_val_now.val[4], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x2D, &acc_val_now.val[5], 1);
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, 0x39, &src_click, 1);
			NRF_LOG_WARNING("SC7A20 CLICK_SRC:0x%02x, ACC VAL: %d %d %d", src_click,
							acc_val_now.val_xyz.x,
							acc_val_now.val_xyz.y,
							acc_val_now.val_xyz.z);
			switch (src_click)
			{
			case 0x5C:
				NRF_LOG_ERROR("Single click -> NZ");
				break;
			case 0x54:
				NRF_LOG_ERROR("Single click -> PZ");
				break;
			case 0x5A:
				NRF_LOG_ERROR("Single click -> NY");
				break;
			case 0x52:
				NRF_LOG_ERROR("Single click -> PY");
				break;
			case 0x59:
				NRF_LOG_ERROR("Single click -> NX");
				break;
			case 0x51:
				NRF_LOG_ERROR("Single click -> PX");
				break;
			}

			uint8_t int1_source = 0;
			global.sc7a20.read_buffer(global.sc7a20.dev_addr, INT1_SOURCE, &int1_source, 1);
			NRF_LOG_DEBUG("INT1_SOURCE 0x%02x",int1_source);
			/*判断是哪个轴产生了中断*/
			if(int1_source & 0x40)
			{
				NRF_LOG_ERROR("INT1_SOURCE IA");
			}
			if(int1_source & 0x20)
			{
				NRF_LOG_ERROR("INT1_SOURCE ZH");
			}
			if(int1_source & 0x10)
			{
				NRF_LOG_ERROR("INT1_SOURCE ZL");
			}
			if(int1_source & 0x08)
			{
				NRF_LOG_ERROR("INT1_SOURCE YH");
			}
			if(int1_source & 0x04)
			{
				NRF_LOG_ERROR("INT1_SOURCE YL");
			}
			if(int1_source & 0x02)
			{
				NRF_LOG_ERROR("INT1_SOURCE XH");
			}
			if(int1_source & 0x01)
			{
				NRF_LOG_ERROR("INT1_SOURCE XL");
			}
```

### 1.4.注意事项

```c
/*
1.配置了XYZ中断每次都会触发事件
2.AOI 位及 6D 位表示触发相应中断事件的规则为：若 AOI=0 为逻辑“或”，
    表示所配置好的所有中断事件只要有一个满足中断条件，就触发中断。若 AOI=1 为逻辑
    “与”，表示所配置好的所有中断事件必须所有都满足自身的中断条件，才能触发中断，相
    当于将所有中断进行了逻辑“与”操作。
3.可判断每次触发的事件是否有变化判断动静
4.中断用于判断是否按照自己需要的方向变化例如(单击双击自由落体)
*/
```

***

## 2.SPL06配置

###  流程图

![image-20211202165053339](E:\Records\资料图片\1638436458(1).jpg)

***



### 2.1宏定义（寄存器和温度气压）

```c
//气压测量速率(sample/sec),Background 模式使用
#define  PM_RATE_1          (0<<4)      //1 measurements pr. sec.
#define  PM_RATE_2          (1<<4)      //2 measurements pr. sec.
#define  PM_RATE_4          (2<<4)      //4 measurements pr. sec.           
#define  PM_RATE_8          (3<<4)      //8 measurements pr. sec.
#define  PM_RATE_16         (4<<4)      //16 measurements pr. sec.
#define  PM_RATE_32         (5<<4)      //32 measurements pr. sec.
#define  PM_RATE_64         (6<<4)      //64 measurements pr. sec.
#define  PM_RATE_128        (7<<4)      //128 measurements pr. sec.

//气压重采样速率(times),Background 模式使用
#define PM_PRC_1            0       //Sigle         kP=524288   ,3.6ms
#define PM_PRC_2            1       //2 times       kP=1572864  ,5.2ms
#define PM_PRC_4            2       //4 times       kP=3670016  ,8.4ms
#define PM_PRC_8            3       //8 times       kP=7864320  ,14.8ms
#define PM_PRC_16           4       //16 times      kP=253952   ,27.6ms
#define PM_PRC_32           5       //32 times      kP=516096   ,53.2ms
#define PM_PRC_64           6       //64 times      kP=1040384  ,104.4ms
#define PM_PRC_128          7       //128 times     kP=2088960  ,206.8ms

//温度测量速率(sample/sec),Background 模式使用
#define  TMP_RATE_1         (0<<4)      //1 measurements pr. sec.
#define  TMP_RATE_2         (1<<4)      //2 measurements pr. sec.
#define  TMP_RATE_4         (2<<4)      //4 measurements pr. sec.           
#define  TMP_RATE_8         (3<<4)      //8 measurements pr. sec.
#define  TMP_RATE_16        (4<<4)      //16 measurements pr. sec.
#define  TMP_RATE_32        (5<<4)      //32 measurements pr. sec.
#define  TMP_RATE_64        (6<<4)      //64 measurements pr. sec.
#define  TMP_RATE_128       (7<<4)      //128 measurements pr. sec.

//温度重采样速率(times),Background 模式使用
#define TMP_PRC_1           0       //Sigle
#define TMP_PRC_2           1       //2 times
#define TMP_PRC_4           2       //4 times
#define TMP_PRC_8           3       //8 times
#define TMP_PRC_16          4       //16 times
#define TMP_PRC_32          5       //32 times
#define TMP_PRC_64          6       //64 times
#define TMP_PRC_128         7       //128 times

//SPL06_MEAS_CFG
#define MEAS_COEF_RDY       0x80
#define MEAS_SENSOR_RDY     0x40        //传感器初始化完成
#define MEAS_TMP_RDY        0x20        //有新的温度数据
#define MEAS_PRS_RDY        0x10        //有新的气压数据

#define MEAS_CTRL_Standby               0x00    //空闲模式
#define MEAS_CTRL_PressMeasure          0x01    //单次气压测量
#define MEAS_CTRL_TempMeasure           0x02    //单次温度测量
#define MEAS_CTRL_ContinuousPress       0x05    //连续气压测量
#define MEAS_CTRL_ContinuousTemp        0x06    //连续温度测量
#define MEAS_CTRL_ContinuousPressTemp   0x07    //连续气压温度测量

//FIFO_STS
#define SPL06_FIFO_FULL     0x02
#define SPL06_FIFO_EMPTY    0x01

//INT_STS
#define SPL06_INT_FIFO_FULL     0x04
#define SPL06_INT_TMP           0x02
#define SPL06_INT_PRS           0x01

//CFG_REG
#define SPL06_CFG_T_SHIFT   0x08    //oversampling times>8时必须使用
#define SPL06_CFG_P_SHIFT   0x04

#define SP06_PSR_B2     0x00        //气压值
#define SP06_PSR_B1     0x01
#define SP06_PSR_B0     0x02
#define SP06_TMP_B2     0x03        //温度值
#define SP06_TMP_B1     0x04
#define SP06_TMP_B0     0x05

#define SP06_PSR_CFG    0x06        //气压测量配置
#define SP06_TMP_CFG    0x07        //温度测量配置
#define SP06_MEAS_CFG   0x08        //测量模式配置

#define SP06_CFG_REG    0x09
#define SP06_INT_STS    0x0A
#define SP06_FIFO_STS   0x0B

#define SP06_RESET      0x0C
#define SP06_ID         0x0D

#define SP06_COEF       0x10        //-0x21
#define SP06_COEF_SRCE  0x28

  	/*spl06 校准参数初始化时需要使用*/
    typedef struct
    {

        int16_t C0;
        int16_t C1;
        int32_t C00;
        int32_t C10;
        int16_t C01;
        int16_t C11;
        int16_t C20;
        int16_t C21;
        int16_t C30;

        float kT;//温度补偿量表因素	
        float kP;//气压补偿量表因素
    } T_SPL06_calibPara;

    /*! 传感器配置结构体*/
    typedef struct 
    {
        uint8_t os_temp;
        uint8_t os_pres;
        uint8_t odr;
        uint8_t filter;
        uint8_t spi3w_en;
    }spl06_config;

    /*传感器状态结构*/
    struct spl06_status
    {
        uint8_t measuring;
        uint8_t im_update;
    };

    /*! @name Uncompensated data structure */
    struct spl06_uncomp_data
    {
        int32_t uncomp_temp;
        int32_t uncomp_press;
    };

    typedef uint32_t (*spl06_dev_write)(uint8_t, uint8_t, uint8_t *, uint16_t);//重定义写函数
    typedef uint32_t (*spl06_dev_read)(uint8_t, uint8_t, uint8_t *, uint16_t);//重定义读函数
    typedef void (*spl06_dev_delay)(uint32_t);//重定义延时函数

    /*! 设备结构 */
    typedef struct
    {
        uint8_t dev_addr;
        uint8_t init_flag;
        uint8_t chip_id;
        T_SPL06_calibPara calib_param;//校准参数结构体
        spl06_config conf;//传感器配置结构体
        spl06_dev_write write_buffer;//写重载函数
        spl06_dev_read read_buffer;//读重载函数
        spl06_dev_delay delay_ms;//延时重载函数
    } spl06_dev;
```
### 2.2重载函数

#### 2.2.1重载写入函数

```c
//参数一：存放设备数据结构体
//参数二：寄存器地址指针 因为可能不止写入一个寄存器
//参数三：要写入的数据指针
//参数四：要写入的寄存器个数
uint32_t spl06_set_regs(const spl06_dev *dev, uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len)
{
    int8_t rslt; //函数返回值
    uint8_t temp_buff[8]; /* 通常不要写超过4个寄存器*/
    uint16_t temp_len;//临时长度
    if (len > 4)//判断是否超过四个
    {
        len = 4;
    }
    //判断是否为空指针
    rslt = null_ptr_check(dev);
    //判断是否为空指针 && 判断寄存器地址是否为空 && 写入数据是否为空
    if ((rslt == SPL06_OK) && (reg_addr != NULL) && (reg_data != NULL))
    {
        if (len != 0)//判断长度是否为0
        {
            temp_buff[0] = reg_data[0];

            /* 写模式 */
            if (len > 1)
            {
                /* Interleave register address w.r.t data for burst write*/
                interleave_data(reg_addr, temp_buff, reg_data, len);
                temp_len = ((len * 2) - 1);
            }
            else
            {
                temp_len = len;
            }
            //写入数据
            rslt = dev->write_buffer(dev->dev_addr, reg_addr[0], temp_buff, temp_len);

            /*检查通信错误并使用内部错误码屏蔽  */
            if (rslt != SPL06_OK)
            {
                rslt = SPL06_E_COMM_FAIL;
            }
        }
        else
        {
            rslt = SPL06_E_INVALID_LEN;
        }
    }
    else
    {
        rslt = SPL06_E_NULL_PTR;
    }

    return rslt;
}
```

#### 2.2.2读取数据重载函数

```c
//参数一：存放设备数据结构体
//参数二：寄存器地址
//参数三：存放读取到的数据变量的地址
//参数四：读取的长度
uint32_t spl06_get_regs(const spl06_dev *dev, uint8_t reg_addr, uint8_t *reg_data, uint8_t len)
{
    int8_t rslt;//返回值
	//判断是否为空	
    rslt = null_ptr_check(dev);
    //判断是否为空 && 存放数据的指针是否为空
    if ((rslt == SPL06_OK) && (reg_data != NULL))
    {
        //读取数据
        rslt = dev->read_buffer(dev->dev_addr, reg_addr, reg_data, len);
        /* 读取失败 检查通信错误并使用内部错误码屏蔽*/
        if (rslt != SPL06_OK)
        {
            rslt = SPL06_E_COMM_FAIL;
        }
    }
    else
    {  
        /* 检查通信错误并使用内部错误码屏蔽*/
        rslt = SPL06_E_NULL_PTR;
    }
    return rslt;
}
```



### 2.3初始化

#### 2.3.1上电复位

```c
int8_t spl06_soft_reset(const spl06_dev *dev)   
{	
    int8_t rslt;//返回值
    uint8_t reset_reg = SPL06_RESET;//存放地址
    uint8_t reg_val = 0x89;//存放要写入的数据
    rslt = null_ptr_check(dev);//判断结构体是否为空指针
    if (rslt == SPL06_OK)//如果等于零则不是空指针
    {
        //将上电复位写入寄存器地址中
        rslt = spl06_set_regs(dev, &reset_reg, &reg_val, 1);//重定义后的往寄存器写函数
        /*根据数据表，启动时间为2毫秒延时两毫秒 */
        dev->delay_ms(2);
    }
    return rslt;
}
```

#### 2.3.2读取设备ID并判断

```c
int8_t spl06_grt_id(const spl06_dev *dev)
{
    int8_t rslt;//返回值
    uint8_t coef[18];//存储初始化所用数据
    uint8_t try_count = 5;//尝试初始化五次以防出错
    rslt = null_ptr_check(dev);//判断是否是空指针
    if (rslt == SPL06_OK)//不是空指针
    {
        while (try_count)//循环尝试初始化五次机会
        {
            //上电复位
            rslt = spl06_soft_reset(dev);
            //复位后系数准备好需要至少40ms  给100ms
            dev->delay_ms(100);
            //判断是否写入成功
            if (rslt == SPL06_OK)
            {
                NRF_LOG_ERROR("spl06_init reset ok");
            }
            //读取id ID 正常情况是0x10
            rslt = spl06_get_regs(dev, SPL06_ID, &dev->chip_id, 1); //重载后写寄存器函数
            /* 判断是否读取成功和id是否为0x10 */
            if ((rslt == SPL06_OK) &&
          				 (dev->chip_id == 0x10))
            {   
                //初始化
                spl06_get_regs(dev, SPL06_COEF, &coef, 18);
                dev->calib_param.C0 = ((int16_t)coef[0] << 4) + ((coef[1] & 0xF0) >> 4);
                dev->calib_param.C0 = (dev->calib_param.C0 & 0x0800) ? (0xF000 | dev->calib_param.C0) : dev->calib_param.C0;
                dev->calib_param.C1 = ((int16_t)(coef[1] & 0x0F) << 8) + coef[2];
                dev->calib_param.C1 = (dev->calib_param.C1 & 0x0800) ? (0xF000 | dev->calib_param.C1) : dev->calib_param.C1;
                dev->calib_param.C00 = ((int32_t)coef[3] << 12) + ((int32_t)coef[4] << 4) + (coef[5] >> 4);
                dev->calib_param.C00 = (dev->calib_param.C00 & 0x080000) ? (0xFFF00000 | dev->calib_param.C00) 
                   																					: dev->calib_param.C00;
                dev->calib_param.C10 = ((int32_t)(coef[5] & 0x0F) << 16) + ((int32_t)coef[6] << 8) + coef[7];
                dev->calib_param.C10 = (dev->calib_param.C10 & 0x080000) ? (0xFFF00000 | dev->calib_param.C10) 
                    																				: dev->calib_param.C10;
                dev->calib_param.C01 = ((int16_t)coef[8] << 8) + coef[9];
                dev->calib_param.C11 = ((int16_t)coef[10] << 8) + coef[11];
                dev->calib_param.C20 = ((int16_t)coef[12] << 8) + coef[13];
                dev->calib_param.C21 = ((int16_t)coef[14] << 8) + coef[15];
                dev->calib_param.C30 = ((int16_t)coef[16] << 8) + coef[17];

                SPL06_Config_Pressure(dev, PM_RATE_4, PM_PRC_32);//配置压力参数函数  参照2.3.2.1
                SPL06_Config_Temperature(dev, PM_RATE_4, TMP_PRC_8);//配置温度参数函数 参照2.3.2.2
                spl06_set_ctrl_mode(dev, MEAS_CTRL_ContinuousPressTemp); //启动连续的气压温度测量函数 

                dev->init_flag = 1;//初始化标志位置1
                break;
            }

            /*没初始化成功等待十毫秒*/
            dev->delay_ms(10);
            --try_count;
        }

        /*判断try_count是否为0；是则芯片id检查失败，超时 */
        if (!try_count)
        {
            rslt = SPL06_E_DEV_NOT_FOUND;
        }
    }
    return rslt;
}
```

##### 2.3.2.1配置压力参数函数

```c
//参数一：存放设备数据结构体
//参数二：气压测量速率
//参数三：气压重采样速率
void SPL06_Config_Pressure(spl06_dev *dev, uint8_t rate, uint8_t oversampling)
{
    uint8_t temp;//临时数据
    uint8_t psr_cfg = SPL06_PSR_CFG;//气压测量配置寄存器地址 0x06
    uint8_t cfg_reg = SPL06_CFG_REG;//FIFO配置(CFG_REG)寄存器地址 0x09
	//判断气压采样速率是多少  设置气压补偿量表因素
    //注：搭配好的不可轻易更改
    switch (oversampling)
    {
    case PM_PRC_1:
        dev->calib_param.kP = 524288;
        break;
    case PM_PRC_2:
        dev->calib_param.kP = 1572864;
        break;
    case PM_PRC_4:
        dev->calib_param.kP = 3670016;
        break;
    case PM_PRC_8:
        dev->calib_param.kP = 7864320;
        break;
    case PM_PRC_16:
        dev->calib_param.kP = 253952;
        break;
    case PM_PRC_32:
        dev->calib_param.kP = 516096;
        break;
    case PM_PRC_64:
        dev->calib_param.kP = 1040384;
        break;
    case PM_PRC_128:
        dev->calib_param.kP = 2088960;
        break;
    }
    
    rate = rate | oversampling; //气压速率 | 气压重采样速率
    spl06_set_regs(dev, &psr_cfg, &rate, 1);//写入压力配置寄存器 压力测量速率的配置
    //暂未知 但写
    if (oversampling > PM_PRC_8)
    {
        spl06_get_regs(dev, cfg_reg, &temp, 1);
        temp = temp | SPL06_CFG_P_SHIFT;
        spl06_set_regs(dev, &cfg_reg, &temp, 1);
    }
}
```

##### 2.3.2.2配置温度参数函数

```c
//参数一：存放设备数据结构体
//参数二：气压测量速率
//参数三：温度重采样速率
void SPL06_Config_Temperature(spl06_dev *dev, uint8_t rate, uint8_t oversampling)
{
    uint8_t temp; //临时数据
    uint8_t tmp_cfg = SPL06_TMP_CFG; //温度测量配置寄存器 0x07
    uint8_t cfg_reg = SPL06_CFG_REG; //FIFO配置(CFG_REG)寄存器地址 0x09
    //判断温度重采样速率是多少  设置温度补偿量表因素
    //注：搭配好的不可轻易更改
    switch (oversampling)
    {
    case TMP_PRC_1:
        dev->calib_param.kT = 524288;
        break;
    case TMP_PRC_2:
        dev->calib_param.kT = 1572864;
        break;
    case TMP_PRC_4:
        dev->calib_param.kT = 3670016;
        break;
    case TMP_PRC_8:
        dev->calib_param.kT = 7864320;
        break;
    case TMP_PRC_16:
        dev->calib_param.kT = 253952;
        break;
    case TMP_PRC_32:
        dev->calib_param.kT = 516096;
        break;
    case TMP_PRC_64:
        dev->calib_param.kT = 1040384;
        break;
    case TMP_PRC_128:
        dev->calib_param.kT = 2088960;
        break;
    }
    //气压速率 | 气压重采样速率 | 0x80
    rate = rate | oversampling | 0x80;
    spl06_set_regs(dev, &tmp_cfg, &rate, 1); //写入温度配置寄存器 温度测量速率的配置 温度每秒128次测量一次
    //暂时未知但写
    if (oversampling > TMP_PRC_8)
    {
        spl06_get_regs(dev, cfg_reg, &temp, 1);
        temp = temp | SPL06_CFG_T_SHIFT;
        spl06_set_regs(dev, &cfg_reg, &temp, 1);
    }
}
```

##### 2.3.2.3选择模式函数

```c
//参数一：存放设备数据结构体
//参数二：模式选择 0-空闲模式  1-单次气压测量  2-单次温度测量  5-连续气压测量  6-连续温度测量  7-连续气压温度测量
void spl06_set_ctrl_mode(spl06_dev *dev, uint8_t mode)
{
    uint8_t reg = SPL06_MEAS_CFG;
    spl06_set_regs(dev, &reg, &mode, 1);
}
```

#####  2.3.2.4不知名函数

```c
//函数作用写入注册数据 
//参数一：存放寄存器地址的指针
//参数二：存放数据的指针
//参数三：数据指针
//参数四：寄存器个数
static void interleave_data(const uint8_t *reg_addr, uint8_t *temp_buff, const uint8_t *reg_data, uint8_t len)
{
    uint8_t index;

    for (index = 1; index < len; index++)
    {
        temp_buff[(index * 2) - 1] = reg_addr[index];
        temp_buff[index * 2] = reg_data[index];
    }
}

```

##### 2.3.2.5检测空指针函数

```c
static int8_t null_ptr_check(const spl06_dev *dev)
{
    int8_t rslt;
    if (dev == NULL)
    {
        /* NULL指针错误宏定义*/
        rslt = SPL06_E_NULL_PTR;
    }
    else
    {
        //不是空
        rslt = SPL06_OK;
    }
    return rslt;
}
```



### 2.4获取ADC值

#### 2.4.1获取气压ADC值
```c
int32_t SPL06_Get_Pressure_Adc(spl06_dev *dev)
{
	//ADC的值由三个组成	
    uint8_t buf[3];
    //ADC的实际值
    int32_t adc;
    //读取三个ADC的三值
    spl06_get_regs(dev, SPL06_PSR_B2, buf, 3);
    //组合成ADC
    adc = (int32_t)(buf[0] << 16) + (int32_t)(buf[1] << 8) + buf[2];
    adc = (adc & 0x800000) ? (0xFF000000 | adc) : adc;
    return adc;
}
```
#### 2.4.2获取温度ADC值
```c
int32_t SPL06_Get_Temperature_Adc(spl06_dev *dev)
{
   	//ADC的值由三个组成	
    uint8_t buf[3];
    //ADC的实际值
    int32_t adc;
    //读取三个ADC的三值
    spl06_get_regs(dev, SPL06_TMP_B2, buf, 3);
     //组合成ADC
    adc = (int32_t)(buf[0] << 16) + (int32_t)(buf[1] << 8) + buf[2];
    adc = (adc & 0x800000) ? (0xFF000000 | adc) : adc;
    return adc;
}
```
### 2.5计算压力值和温度值
```c
float ReadSPL06_Pressure(spl06_dev *dev)
{
	//判断初始化标志位是否为真 判断是否初始化
    if (dev->init_flag)
    {
        float Traw_src, Praw_src;
        float Temp;
        float qua2, qua3;
        int32_t raw_temp, raw_press;//临时存放 ADC值

        raw_temp = SPL06_Get_Temperature_Adc(dev);
        raw_press = SPL06_Get_Pressure_Adc(dev);

        Traw_src = raw_temp / dev->calib_param.kT;
        Praw_src = raw_press / dev->calib_param.kP;

        //计算温度 公式直接套用
        Temp = 0.5f * dev->calib_param.C0 + Traw_src * dev->calib_param.C1;
        dev->current_temperature_val = (uint8_t)Temp;

        //计算气压  
        qua2 = dev->calib_param.C10 + Praw_src * (dev->calib_param.C20 + Praw_src * dev->calib_param.C30);
        qua3 = Traw_src * Praw_src * (dev->calib_param.C11 + Praw_src * dev->calib_param.C21);
        //原dev->current_pressure_val = (uint16_t)((dev->calib_param.C00 + Praw_src * qua2 + Traw_src * dev->calib_param.C01 + qua3) 1hpa=100Pa  从输出hPa 百帕 除100 得 pa
        dev->current_pressure_val = (uint16_t)((dev->calib_param.C00 + Praw_src * qua2 + Traw_src * dev->calib_param.C01 + qua3) / 100);
        return dev->current_pressure_val;
    }
    else
    {
        //返回错误
        return SPL06_E_DEV_NOT_FOUND;
    }
}
```